Entendido:
âœ” o **pod nÃ£o tem saÃ­da externa**
âœ” **nÃ£o pode instalar curl, wget, apk, yum etc.**
âœ” ainda assim vocÃª precisa **gerar stress de memÃ³ria a partir DE DENTRO do pod**.

A melhor alternativa nessas condiÃ§Ãµes Ã© **usar o `rabbitmqadmin` (que jÃ¡ vem no RabbitMQ Management Plugin)** para publicar mensagens enormes em loop infinito. Isso **aumenta rapidamente o uso de memÃ³ria das filas**, levando ao **OOMKill do RabbitMQ**.

---

## âœ… SCRIPT DE STRESS 100% LOCAL, SEM DOWNLOAD E SEM DEPENDÃŠNCIAS EXTERNAS

> Executar **de dentro do pod que tenha o `rabbitmqadmin`** (pode ser o prÃ³prio pod do RabbitMQ ou um pod sidecar contendo a CLI).

Crie o arquivo:

```bash
cat << 'EOF' > /tmp/stress_oom_local.sh
#!/bin/bash

QUEUE="stress-queue"
ROUTING_KEY="stress"
EXCHANGE="stress-exchange"

# tamanho da mensagem â€” ajuste para acelerar o OOMKill
MSG_SIZE=1000000   # 1 MB

# quantas mensagens por ciclo
BATCH=200

# corpo da mensagem grande
PAYLOAD=$(printf 'A%.0s' $(seq 1 $MSG_SIZE))

echo "ğŸš€ Iniciando stress de memÃ³ria no RabbitMQ..."
echo "   Tamanho da mensagem: $MSG_SIZE bytes"
echo "   Batch: $BATCH por ciclo"
echo ""

while true; do
  for i in $(seq 1 $BATCH); do
    rabbitmqadmin publish \
      exchange=$EXCHANGE \
      routing_key=$ROUTING_KEY \
      payload="$PAYLOAD" \
      properties='{"delivery_mode":2}'
  done
  echo "[+] $BATCH mensagens enviadas"
done
EOF

chmod +x /tmp/stress_oom_local.sh
```

---

## â–¶ Executar

```bash
/tmp/stress_oom_local.sh
```

O script vai rodar continuamente atÃ©:

ğŸ”¹ o watermark explodir â†’ produtores passam a bloquear
ğŸ”¹ o container exceder a memÃ³ria do Kubernetes â†’ **OOMKill**

---

## âš  Antes de rodar, garanta a existÃªncia dos recursos

Execute dentro do pod (se ainda nÃ£o estiver preparado):

```bash
rabbitmqctl add_user stress pass123
rabbitmqctl set_permissions -p / stress ".*" ".*" ".*"

rabbitmqadmin declare exchange name=stress-exchange type=direct durable=true
rabbitmqadmin declare queue name=stress-queue durable=true
rabbitmqadmin declare binding source=stress-exchange destination=stress-queue routing_key=stress
```

E **use o usuÃ¡rio stress no script** se for necessÃ¡rio autenticaÃ§Ã£o:

```bash
export RABBITMQ_USER=stress
export RABBITMQ_PASSWORD=pass123
```

---

## â© Para acelerar ainda mais o OOMKill

Rodar antes do stress:

```bash
rabbitmqctl set_vm_memory_high_watermark 0.95
```

E se quiser **garantir que as mensagens fiquem na memÃ³ria e nÃ£o no disco**, configure:

```bash
rabbitmqctl eval 'rabbit_amqqueue:declare_lazy(<<"stress-queue">>, false).'
```

---

## ğŸ§¨ Resultado esperado

| Comportamento                 | Minutos aproximados |
| ----------------------------- | ------------------- |
| Crescimento da fila e memÃ³ria | 0â€“1 min             |
| RabbitMQ atinge watermark     | 1â€“2 min             |
| Pod trava ou limita           | 2â€“4 min             |
| **OOMKill** (queda do pod)    | 3â€“8 min             |

---

Se quiser, eu tambÃ©m consigo gerar alternativas conforme a sua necessidade:

ğŸ”¹ script com paralelismo (vÃ¡rios loops simultÃ¢neos)
ğŸ”¹ script para stress de CPU ao invÃ©s de memÃ³ria
ğŸ”¹ script reverso para limpar filas apÃ³s o teste

SÃ³ me dizer qual vocÃª precisa. ğŸš€
