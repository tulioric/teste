Perfeito â€” vocÃª acabou de instalar o RabbitMQ e quer:

âœ” criar os recursos necessÃ¡rios para testes (fila, exchange, binding, usuÃ¡rio, permissÃµes)
âœ” rodar **um script de stress para causar OOMKill (estouro de memÃ³ria)**

Vou organizar em passos prÃ¡ticos para facilitar.

---

# ğŸŸ¢ 1) Criar recursos essenciais para o teste

### Criar **usuÃ¡rio de stress**

```bash
rabbitmqctl add_user stress pass123
rabbitmqctl set_user_tags stress administrator
rabbitmqctl set_permissions -p / stress ".*" ".*" ".*"
```

### Criar **exchange**

```bash
rabbitmqadmin declare exchange \
  name=stress-exchange \
  type=direct \
  durable=true
```

### Criar **fila**

```bash
rabbitmqadmin declare queue \
  name=stress-queue \
  durable=true
```

### Criar **binding**

```bash
rabbitmqadmin declare binding \
  source=stress-exchange \
  destination=stress-queue \
  routing_key=stress
```

> Se `rabbitmqadmin` nÃ£o estiver instalado:

```bash
curl http://localhost:15672/cli/rabbitmqadmin -o /usr/local/bin/rabbitmqadmin
chmod +x /usr/local/bin/rabbitmqadmin
```

---

# ğŸŸ  2) Verificar memÃ³ria atual antes do teste

```bash
rabbitmq-diagnostics memory_breakdown
rabbitmq-diagnostics status | grep vm_memory_high_watermark
```

Se quiser subir o limite para acelerar o OOMKill (Ãºtil quando o container tem muita memÃ³ria):

```bash
rabbitmqctl set_vm_memory_high_watermark 0.95
```

---

# ğŸ”¥ 3) Script de stress para gerar **OOMKill**

Esse script produz mensagens **grandes e rÃ¡pidas** atÃ© o RabbitMQ ultrapassar o limite de memÃ³ria e ser derrubado pelo Kubernetes.

### Script `stress_oom.sh`

```bash
#!/bin/bash

URL="amqp://stress:pass123@localhost:5672/"
EXCHANGE="stress-exchange"
ROUTING="stress"
MESSAGE_SIZE=1000000   # 1 MB por mensagem
RATE=1000              # 1000 msgs/segundo
RUNTIME=0              # 0 = infinito

echo "Iniciando teste de stress para OOMKill..."
docker run --rm \
  pivotalrabbitmq/perf-test \
  --uri $URL \
  --exchange $EXCHANGE \
  --routing-key $ROUTING \
  --producers 10 \
  --consumers 0 \
  --body-size $MESSAGE_SIZE \
  --rate $RATE \
  --auto-delete false \
  --duration $RUNTIME
```

Executar:

```bash
chmod +x stress_oom.sh
./stress_oom.sh
```

---

## ğŸ’£ Resultado esperado

| Impacto                                    | Tempo aproximado    |
| ------------------------------------------ | ------------------- |
| Crescimento rÃ¡pido da fila                 | Segundos            |
| Escalonamento agressivo de memÃ³ria         | < 1 min             |
| RabbitMQ atinge watermark                  | pausa de produtores |
| Estoura memÃ³ria do container â†’ **OOMKill** | 1â€“3 min             |

---

# ğŸ” Monitoramento durante o teste

### MemÃ³ria

```bash
watch rabbitmq-diagnostics memory_breakdown
```

### Tamanho da fila

```bash
rabbitmqctl list_queues name messages memory
```

### Logs

```bash
kubectl logs -f <POD>  # caso esteja no Kubernetes/OpenShift
```

---

## âš ï¸ Avisos importantes

Para garantir que dÃª OOMKill de verdade:

| Local                  | AÃ§Ã£o necessÃ¡ria                                             |
| ---------------------- | ----------------------------------------------------------- |
| Kubernetes / OpenShift | **limits.memory deve ser MENOR que a memÃ³ria real do host** |
| RabbitMQ               | `vm_memory_high_watermark` alto acelera OOMKill             |
| PVC / disco            | Fazer fila crescer em **memÃ³ria**, nÃ£o usar `lazy queue`    |

Se vocÃª quiser, posso gerar tambÃ©m:

ğŸ”¹ YAML de StatefulSet do RabbitMQ otimizado para testes de OOM
ğŸ”¹ Probe de readiness executando `rabbitmq-diagnostics -q memory_breakdown`
ğŸ”¹ Grafana dashboard para acompanhar o teste

Basta dizer se estÃ¡ usando **Docker, Kubernetes ou OpenShift**. ğŸš€
