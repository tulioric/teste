Entendido â€” vocÃª quer **um script que rode dentro do prÃ³prio pod do RabbitMQ (ou dentro de um pod auxiliar)** sem depender de `docker run` externo, para gerar stress e causar OOMKill.

A melhor forma Ã© usar o **RabbitMQ PerfTest em Java**, pois ele envia mensagens grandes rapidamente sem precisar de instalar clientes extras.

Abaixo estÃ¡ um script **100% local**, que pode ser executado diretamente **dentro do pod** (ou dentro de um pod sidecar/container de teste).

---

## âœ… 1) Baixar o PerfTest (sÃ³ uma vez dentro do pod)

```bash
curl -O https://repo1.maven.org/maven2/com/rabbitmq/perf-test/2.20.0/perf-test-2.20.0.jar
```

> Caso `curl` nÃ£o esteja disponÃ­vel, usar `wget`:

```bash
wget https://repo1.maven.org/maven2/com/rabbitmq/perf-test/2.20.0/perf-test-2.20.0.jar
```

---

## ğŸ§¨ 2) Script local de stress `stress_oom_local.sh`

Crie o arquivo dentro do pod:

```bash
cat << 'EOF' > /tmp/stress_oom_local.sh
#!/bin/bash

URL="amqp://stress:pass123@localhost:5672/"
EXCHANGE="stress-exchange"
ROUTING="stress"
MESSAGE_SIZE=1000000   # 1 MB por mensagem
PRODUCERS=10
RATE=1000              # 1000 msgs/segundo por produtor
DURATION=0             # 0 = infinito (atÃ© OOMKill)

echo "ğŸ“Œ Iniciando stress de memÃ³ria contra o RabbitMQ..."
echo "   Body size: $MESSAGE_SIZE bytes"
echo "   Producers: $PRODUCERS"
echo "   Rate: $RATE msgs/s"
echo "   Duration: infinito"

java -jar /tmp/perf-test.jar \
  --uri $URL \
  --exchange $EXCHANGE \
  --routing-key $ROUTING \
  --producers $PRODUCERS \
  --consumers 0 \
  --body-size $MESSAGE_SIZE \
  --rate $RATE \
  --id "stress-oom" \
  --auto-delete false \
  --duration $DURATION
EOF
chmod +x /tmp/stress_oom_local.sh
```

---

## ğŸš€ 3) Executar o script dentro do pod

Assumindo que o `perf-test.jar` foi colocado em `/tmp/perf-test.jar`:

```bash
mv perf-test-2.20.0.jar /tmp/perf-test.jar
/tmp/stress_oom_local.sh
```

O teste comeÃ§arÃ¡ e continuarÃ¡ atÃ© o RabbitMQ entrar em **OOMKill**.

---

# ğŸ§ª Recursos esperados para stress

Certifique-se de que o RabbitMQ jÃ¡ tem antes do teste:

```bash
rabbitmqctl add_user stress pass123
rabbitmqctl set_permissions -p / stress ".*" ".*" ".*"

rabbitmqadmin declare exchange name=stress-exchange type=direct durable=true
rabbitmqadmin declare queue name=stress-queue durable=true
rabbitmqadmin declare binding source=stress-exchange destination=stress-queue routing_key=stress
```

---

## ğŸ”¥ Dicas para acelerar o OOMKill

Se quiser forÃ§ar o RabbitMQ usar quase toda memÃ³ria disponÃ­vel (opcional):

```bash
rabbitmqctl set_vm_memory_high_watermark 0.95
```

---

## ğŸ“Œ Resultado tÃ­pico do teste

O teste causa:

| Efeito                         | Tempo esperado  |
| ------------------------------ | --------------- |
| Crescimento da fila em memÃ³ria | Alguns segundos |
| Watermark atingido             | ~30â€“90 segundos |
| Travamento dos produtores      | Antes do crash  |
| **OOMKill (queda do pod)**     | ~1â€“5 minutos    |

---

Se quiser, posso gerar tambÃ©m:
ğŸ’  manifesto Kubernetes com pod de stress jÃ¡ contendo este script
ğŸ’  readiness probe usando `rabbitmq-diagnostics -q memory_breakdown`
ğŸ’  script reverso para limpar recursos apÃ³s o stress

Ã‰ sÃ³ pedir. ğŸš€
